# 백준 14442번_벽 부수고 이동하기 2(골드3)
https://www.acmicpc.net/problem/14442

## 문제 설명
1인 벽 k개를 부수고 이동할 수 있는 최단 거리 구하기

## 문제 접근 방법
k개를 구하는 방법을 combination함수를 이용해서 구했다. 


## 코드(메모리초과)
```python
from itertools import combinations
from collections import deque

n, m, k = map(int, input().split())
graph = [] #맵
wall = [] #벽의 좌표
for i in range(n):
    graph.append(list(map(int, input())))
    for j in range(m):
        if graph[i][j] == 1: #벽이라면
            wall.append([i, j])
    
# 1. 벽(1)중 k개를 고르기
# 2. k개가 부셔진 맵에 최단경로 구하기->dfs
# 3. 각 조합에서 가장 짧은 수 프린트

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    q = deque()
    q.append((x, y))
    array[x][y] = 1
    while q:
        x, y = q.popleft() #좌표(x, y)와 거리(d)
        for i in range(4):
            nx = x+dx[i]
            ny = y+dy[i]
            if 0<=nx<n and 0<=ny<m:
                if array[nx][ny] == 0: #이동할 수 있는 곳만
                    array[nx][ny] += array[x][y]+1 #거리를 추가해서 값 저장
                    q.append((nx, ny)) #거리 +1 해서 다음 좌표로 저장 
                    
    return array[n-1][m-1] #거리 반환
    
answer = 1e9
for t in list(combinations(wall, k)): # 1. 벽(1)중 k개를 고르기
    array = [[0]*m for _ in range(n)] #부셔진 벽을 가진 새로운 리스트
    for i in range(n):
        for j in range(m):
            array[i][j] = graph[i][j]
            if [i, j] in t:
                array[i][j] = 0 #벽이 부셔졌으니 1->0값으로 변함
                
    d = dfs(0, 0) #(1, 1)좌표에서 시작한다. 
    if d != 0: #최단거리가 나올경우
        answer = min(answer, d)

if answer == 1e9: #최단거리가 불가능할떄
    print(-1)
else:
    print(answer)    
   
```
* 너무 맞는 로직인데 왜 메모리초과일까...싶었지만 combination을써서 메모리 초과일까 생각했다.

## 문제 접근 방법
k개를 구하는 방법을 벡트레킹 방법을 이용했다. 

## 코드(시간초과)
```python
from collections import deque

n, m, k = map(int, input().split())
graph = [] #맵
wall = [] #벽의 좌표
for i in range(n):
    graph.append(list(map(int, input())))
    for j in range(m):
        if graph[i][j] == 1: #벽이라면
            wall.append([i, j])

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    q = deque()
    q.append((x, y))
    array[x][y] = 1
    while q:
        x, y = q.popleft() #좌표(x, y)와 거리(d)
        for i in range(4):
            nx = x+dx[i]
            ny = y+dy[i]
            if 0<=nx<n and 0<=ny<m:
                if array[nx][ny] == 0: #이동할 수 있는 곳만
                    array[nx][ny] += array[x][y]+1 #거리를 추가해서 값 저장
                    q.append((nx, ny)) #거리 +1 해서 다음 좌표로 저장 
                    
    return array[n-1][m-1] #거리 반환
    
answer = []
array = [[0]*m for _ in range(n)]

#백트레킹 이용
def dfs02(count):
    global answer
    if count == k:
        for i in range(n):
            for j in range(m):
                array[i][j] = graph[i][j]
                
        d = dfs(0, 0)
        if d != 0:
            answer.append(d)
        return
    
    for i in range(n):
        for j in range(m):
            if graph[i][j] == 1:
                graph[i][j] = 0
                count+=1
                dfs02(count)
                graph[i][j] = 1
                count-=1
dfs02(0)    
            
if len(answer)==0:
    print(-1)
else:
    print(min(answer))
```
* n, m이 최대 10000임으로 시간복잡도는 O(nm) = 1,000,0000반복이다 -> 시간초과가 당연


## 문제 접근 방법
1. graph[k][x][y]를 두어서 벽을 k개 부순상태의 x, y좌표의 방문 기록을 만들어준다. 
2. bfs로 이동할때는 벽을 부수고 이동 / 부수지 않고 이동의 두가지 상태를 나눠준다. 

## 코드(블로그 참고)
```python
from collections import deque

n, m, k = map(int, input().split())
map = [list(map(int, input().split())) for _ in range(n)]

#벽을 k개 부술때의 좌표 방문 기록
# graph[1][2][3] = 1 의 의미는 벽을 1개 부쉈을때 [2,3]을 방문 했다 
# k+1 인 이유는 아예 안부쉈을때 / 1개부쉈을때 / ... / k개 부쉈을때 이렇게 총 k+1개이다.
graph = [[[0]*m for _ in range(n)] for _ in range(k+1)] 

dx = [-1, 1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y, cnx): # 좌표와 벽을 몇개 부순상태인지=cnx
    q = deque()
    q.append((x, y, 0, 1)) # 좌표, 벽을 몇개 부순상태인지, 거리
    
    while q:
        x, y, brk_wall, dist = q.popleft()# 좌표, 벽을 몇개 부순상태인지, 거리
        if x == n-1 and y == m-1: #도착까지 도달한다면
            return dist #거리 반환
        
        for i in range(4):
            nx = x+dx[i]
            ny = y+dy[i]
            if 0<=nx<n and 0<=ny<m: #그래프 범위안에 들고
                # 벽을 부수고 이동 = 벽이 있고 / 부술수있으며 / 해당 부수는 갯수에서 아직 방문하지 않은 상태다 
                if map[nx][ny]==1 and brk_wall<k and graph[brk_wall+1][nx][ny] == 0:
                    q.append((nx, ny, brk_wall+1, dist+1)) #한번 부쉈으니 brk_wall + 1
                    graph[brk_wall+1][nx][ny] = 1 #방문 기록
                # 벽을 안부수고 이동 = 벽이 없고 / 아직 방문하지 않은 상태다
                elif map[nx][ny]==0 and graph[brk_wall][nx][ny] == 0:
                    q.append((nx, ny, brk_wall, dist+1))
                    graph[brk_wall][nx][ny] = 1
                    
    return -1 #방법이 없을 경우  
                    
print(bfs(0, 0))
        
```