# 백준 2422번_한윤정이 이탈리아에 가서 아이스크림을 사먹는데(실버5)
https://www.acmicpc.net/problem/2422
<br>
풀이에 걸린 시간 : 60분(시간초과)    

## 문제 설명
n종류의 아이스크림을 3개 선택하는데 주어진 조합이 포함되지 않은 경우의 수를 구하기

## 문제 접근 방법
시간제한이 1초이기 때문에 combination함수를 이용하는 것이 아니라 dfs를 통해 조합을 구하는게 맞다고 생각했다. 
1. n종류의 조합을 bfs를 통해 구하기
2. 각 조합이 3자리 수이니깐, 3개를 2개로 combination해서 조합(3개)에서 나오는 조합(2개)이 섞어먹으면 안되는 조합리스트에 있지 않은 경우만 answer에 저장
3. answer길이 출력

## 코드(시간초과)
```python
from itertools import combinations

n, m = map(int, input().split())
icecream = []
for i in range(m):
    icecream.append(list(map(int, input().split())))

l = [i for i in range(1, n+1)]
nn = len(l)

answer = []

def dfs(idx, listtt):
    if len(listtt) == m:
        combi = list(combinations(listtt, 2))
        cnx = 0
        for i in combi:
           if list(i) in icecream:
               cnx+=1
               break
           
        if cnx == 0: #포함되는것이 없다
            answer.append(listtt)
            return

    for i in range(idx, nn):
        dfs(i+1,listtt+[l[i]])

dfs(0, [])
print(len(answer))
```
* 틀린이유: 처음에는 combination에서 시간초과가 걸린줄알았지만 해당 부분을 제거하고 dfs부분만 돌려도 시간초과가 났다. 저 부분에 시간초과가 난듯하다. 


## 문제 접근 방법
1. icecream을 [1, 2], [3, 4], [1, 3]이면 앞에 수 인덱스에 뒤에 수 값으로 2중 리스트를 만들었다. [[], [2, 3], [], [4], []]
2. combination을 통해 3가지 조합을 구하고 
3. 조합에서 for문을 돌면서 조합에 포함된 값을 icecream[i]에 넣어서 값이 그 조합에 있지 않은 경우만 값을 세준다. 

## 코드 (시간초과)
```python
from itertools import combinations

n, m = map(int, input().split())
icecream = [[] for _ in range(n+1)]
for i in range(m):
    a, b = map(int, input().split())
    icecream[a].append(b)

answer = 0
array = [i for i in range(1, n+1)]
for i in list(combinations(array, 3)):
    cnx = True
    for j in i:
        for v in icecream[j]:
            if v in i:
                cnx = False
                break
    if cnx:
        answer+=1
print(answer)
```
* 처음 코드에서 dfs부분이 시간초과가 나서 설마하는 마음으로 처음부터 combination을 통해 3가지 조합을 구하려고 해보았다. 역시 시간초과

## 문제 접근 방법
1. 이중리스트로 나와서는 안되는 조합을 1, 디폴트는 0으로 해서 graph[i][j]값으로 (i, j)조합의 허용여부를 확인했다.
2. 3개 조합의 경우 bfs나 combination을 쓰지 않고 그냥 3중for문을 이용
3. (i, j, k) 조합을 2개씩 경우를 나워서 이중리스트에 0, 1값을 확인해서 카운트를 셌다.


## 맞은코드(블로그 참고)
```python
n, m = map(int, input().split())
graph = [[0]*n for _ in range(n)]

for i in range(m):
    a, b = map(int, input().split())
    a-=1
    b-=1
    graph[a][b] = 1
    graph[b][a] = 1

cnx=0
for i in range(n):
    for j in range(i):
        for k in range(j):
            if graph[i][j] == 0 and graph[i][k] == 0 and graph[j][k]==0:
                cnx+=1
                
print(cnx)
```
* 하 진짜 쉽게 풀었다...왜 이 방법을 생각못했지