# [백준] bfs - 모래성
https://www.acmicpc.net/problem/10711

## 문제 접근 
> .과 9가 아닌(9가 아닌 이유는 방향 다 돌아도 8이기때문에 9는 안세도된다 생각)숫자들만 돌면서 8영역 체크하는 함수(nineNine)를통해 주면 .를 세줌 -> 센 갯수가 본인보다 크거나 같으면 리스트에 넣어주고, 다끝난뒤 리스트를 다시 돌면서 .으로 바꿔줌 이 동작을 while하면서 sand값(주변에 .이 있는 모래)가 하나도 없으면 프린트하고 출력
> 이렇게 하면 h와 w의 범위가 1000이니깐 O(1000^3)임으로 시간초과 발행 

## 코드(테케 맞고 & 11%에서 시간초과)
```python
h, w = map(int, input().split())
graph = []
for _ in range(h):
    graph.append(list(input()))
    
def nineNine(graph, x, y):
    count = 0
    for i in range(-1, 2):
        for j in range(-1, 2):
            if graph[x+i][y+j] == '.':
                count+=1
    return count   

answer = 0
while True:
    sand = []
    for i in range(h):
        for j in range(w):
            if graph[i][j] != '.':
                wave =nineNine(graph, i, j)
                if wave >= int(graph[i][j]):
                    sand.append([i, j])

    if len(sand) == 0:
        print(answer)
        break
                         
    for i in range(len(sand)):
        x = sand[i][0]
        y = sand[i][1]
        graph[x][y] = '.'

    answer+=1
```
    
## 문제 접근 
> bfs를 이용해서 먼저 .이 있는 좌표를 큐에 넣어준다. 그리고 큐를 돌면서 8방향을 확인해보고 숫자가 있다면 -1을 해준다. 그렇게 해서 0이 되면 그 모래성이 무너지는 거니깐 다시 큐에 넣는다. 
> https://paris-in-the-rain.tistory.com/122 
> 해설 참고했음

## 코드(테케 맞고 & 22%에서 시간초과) -> pypy3로 하니깐 맞음
```python
from collections import deque

h, w = map(int, input().split())
graph = []
for _ in range(h):
    graph.append(list(input()))

dx = [-1, 1, -1, 1, 1, -1, 0, 0] #대각선, 상하 좌우
dy = [-1, 1, 1, -1, 0, 0, 1, -1]
q=deque()

for i in range(h):
    for j in range(w):
        if graph[i][j] == '.':
            graph[i][j] = 0 #편하게 0으로 바꾸자
            q.append((i, j, 0))
        else:
            graph[i][j] = int(graph[i][j]) #숫자는 int타입으로 바꾸기

while q:
    x, y, cnx = q.popleft()
    for i in range(8):
        nx = x+dx[i]
        ny = y+dy[i]
        if 0<=nx<h and 0<=ny<w and graph[nx][ny] != 0:
            graph[nx][ny]-=1
            if graph[nx][ny] == 0:
                q.append((nx, ny, cnx+1))

print(cnx)
