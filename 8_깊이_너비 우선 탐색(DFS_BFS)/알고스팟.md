# [백준] dfs/bfs - 알고스팟
https://www.acmicpc.net/problem/1261

## 문제 접근 방법
> (첫번쨰 코드) 다음 가는 칸이 0이고 & 한번도 방문 안했을때 큐에 넣어줌 근데 모든 면이 1일 경우(0이 없을 경우)는 모든 면을 다 큐에 넣어줌 방문은 따로 그래프 만들어서 방문확인해줌
> (인터넷 참고) 비용이 0이면 appendleft 를 해서 큐 앞부분에 놓고 1이면 그냥 append를 해서 큐에 넣는다. 그러면 작은 비용만 먼저 탐색하게 되어서 최소 벽의 수를 찾을 수 있다. 
https://velog.io/@aonee/%EB%B0%B1%EC%A4%80-boj-1261-%EC%95%8C%EA%B3%A0%EC%8A%A4%ED%8C%9F-%ED%8C%8C%EC%9D%B4%EC%8D%AC
우선순위가 있을경우에 appendleft시키는게 중요하다!! 


## 코드(틀림, 테스트케이스는 맞음)
```python
from collections import deque

m, n = map(int, input().split())
graph = []
for i in range(n):
    graph.append(list(map(int, input())))
    
visited = [[0 for _ in range(m)] for _ in range(n)]
visited[0][0] = 1   

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dfs(x, y):
    queue = deque()
    queue.append((x, y))

    while queue:
        x, y = queue.popleft()
        check = True
    
    
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if nx<0 or ny<0 or nx>=n or ny>= m or graph[nx][ny] ==1 :
                continue
            
            if graph[nx][ny] == 0 and visited[nx][ny] == 0:
                check = False
                graph[nx][ny] += graph[x][y] 
                visited[nx][ny] = 1
                queue.append((nx, ny))
                
        if check:
            for i in range(4):
                nx = x + dx[i]
                ny = y + dy[i]
                if nx<0 or ny<0 or nx>=n or ny>= m:
                    continue
                if visited[nx][ny] == 0:
                    graph[nx][ny] += graph[x][y] 
                    visited[nx][ny] = 1
                    queue.append((nx, ny))
                    
    return graph[n-1][m-1]

print(dfs(0, 0))
```

## 코드
```python
from collections import deque

m, n = map(int, input().split())
graph = []
for i in range(n):
    graph.append(list(map(int, input())))
    
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

weight = [[-1] * m for _ in range(n)] #가중치를 계산
weight[0][0] = 0


queue = deque()
queue.append((0, 0))

while queue:
    x, y = queue.popleft()
    
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]
        if 0<=nx<n and 0<=ny<m: #범위가 넘지 않고
            if weight[nx][ny] == -1: # 한번도 방문하지 않고
                if graph[nx][ny] == 0: #다음 벽이 0
                    weight[nx][ny] = weight[x][y] #가중될게 없음 
                    queue.appendleft((nx, ny)) #다음 벽이 0이니깐 우선순위가 먼저가됨
                else: #다음 벽이 1
                    weight[nx][ny] = weight[x][y] + 1 # 1가중시킴
                    queue.append((nx, ny)) #다음 벽이 1이니깐 그냥 뒤에 삽입
                
                

print(weight[n-1][m-1])
```