# [백준] bfs - 빙산
https://www.acmicpc.net/problem/2573

## 문제 접근 
> 처음에는 2차원 배열을 2개 만들었다. 방문리스트(visited), 줄어든빙산을 저장할 리스트 그러면 총 3개의 배열이 나오는데(원래 배열포함) 다른 사람 풀이보니 이렇게 푼 사람도 있었는데 나는 너무 중간에 헷갈려서 결국 잘 못풀었다. 
> 
> https://hbj0209.tistory.com/m/161?category=909676 이 블로그를 참고했다. 이 사람은 줄어든 빙산을 리스트에 저장하지 않고 defaultdict를 써서 줄어들 빙산의 좌표, 줄어든 크기를 저장하였다. 
이렇게 저장하고 bfs를 돌려 빙산이 몇개 나오는지 확인한다. 빙산이 2이상이 나올떄까지 돌려야됨으로 while문을 써주었고 bfs에서 저장한 딕셔너리를 가지고 원래 리스트에서 값을 뺴준다. 

## 코드
```python
from collections import defaultdict, deque

n, m = map(int, input().split())
graph = []
for i in range(n):
    graph.append(list(map(int, input().split())))
    
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]  

# 딕셔너리를 이용해서 녹을 빙하의 좌표, 몇개(?) 녹을건지 bfs를 돌려서 찾아냄
def bfs(x, y, visited):
    ice = defaultdict(int)
    queue = deque()
    queue.append((x, y))
    visited[x][y] = True
    
    while queue:
        x, y = queue.popleft()
        for i in range(4):
            nx = x+dx[i]
            ny = y+dy[i]
            if 0<=nx<n and 0<=ny<m:
                if graph[nx][ny] == 0: # 0이면 갯수를 세고
                    ice[(x, y)]+=1
                elif graph[nx][ny] != 0 and visited[nx][ny] == False:
                    visited[nx][ny] = True
                    queue.append((nx, ny))                  
    return ice

year= 0
while True: # 빙산이 분리 될떄까지 찾아야되니깐
    iceberg = 0
    visited = [[False]*m for _ in range(n)] #돌릴때마다 visited를 갱신 시켜야되니깐 while 안에 선언하는게 맞음
    
    for i in range(n):
        for j in range(m):
            if graph[i][j] != 0 and visited[i][j] == False:
                iceberg+=1
                ice_map = bfs(i, j, visited)
                
    for x, y in ice_map:
        graph[x][y] = max(0, graph[x][y]-ice_map[(x, y)]) # 0보다 낮으면 그냥 0이 됨으로

    if iceberg >= 2: #빙산이 2개 이상이 되면 출력
        print(year)
        break
    if iceberg == 0: #다 녹을때까지 분리되지 않으면 0 출력
        print(0)
        break
    year+=1
```
