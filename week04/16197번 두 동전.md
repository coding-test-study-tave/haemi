# 백준_16197 두 동전
https://www.acmicpc.net/problem/16197

## 문제 설명
두 동전을 동시에 움직이면서 한 동전만 떨어질때 최소버튼수를 구한다.
벽이 있다면 움직이지 않는다. 

## 문제 접근
* 방문표시를 하지 않았다 -> 10번 미만으로 움직이기때문에 무한 루프로 빠질일이 없다.
* 두개다 떨어질떄만 어떻게 풀지 몰랐지만 continue로 해서 그냥 무시하면된다(블로그 참고)
1. 큐에 두개의 동전의 좌표와 이동횟수를 넣어준다.
2. 큐를 bfs하면서 #를 만날때는 움직이지 않으니 원래 좌표를 넣어준다.
3. 한 동전만 밖으로 이동하면 길이를 return
4. 10번 이상이 되면 -1을 return
5. **(블로그 참고ㅠㅠ) 두개다 떨어질때는 무조건 -1이 아니니깐 continue를 하면서 해당 건수는 무시한다. 

## 코드
```python
from collections import deque

n, m = map(int, input().split())
graph = []
coin = []
for i in range(n):
    graph.append(list(input()))
    for j in range(m):
        if graph[i][j] == 'o':
            coin.append(i)
            coin.append(j)

coin.append(0)
            
dx = [0, 0, -1, 1]
dy = [1, -1, 0, 0]

q = deque()
q.append(coin)

def dfs():
    while q:
        first_x, first_y, second_x, second_y, depth = q.popleft()
        if depth >= 10:
            return -1
            
        for i in range(4):
            f_dx, f_dy, s_dx, s_dy = first_x+dx[i], first_y+dy[i], second_x+dx[i], second_y+dy[i]
            
            if  0 <= f_dx < n and 0 <= f_dy < m and 0 <= s_dx < n and 0 <= s_dy < m:
                if graph[f_dx][f_dy] == '#':
                    f_dx, f_dy = first_x, first_y
                if graph[s_dx][s_dy] == '#':
                    s_dx, s_dy = second_x, second_y
                q.append((f_dx, f_dy, s_dx, s_dy, depth+1))        
            
            # 첫번쨰만 떨어질떄 
            elif 0<=f_dx<n and 0<=f_dy<m:
                return depth+1
            # 두번쨰만 떨어질떄
            elif 0<=s_dx<n and 0<=s_dy<m:
                return depth+1
            # 두개 다 떨어질때 
            else:
                continue
    return -1

print(dfs())
    
```
*거의다 풀었는데 두개다 떨어질떄 continue를 생각하지 못했다 너무 아쉽다. 